---
layout: post
title: "SPI, I2C, UART là gì? Chúng khác nhau ở điểm nào?"
date: 2025-10-11
tags: [theoritical, protocol]
---

Trong hệ thống nhúng, việc trao đổi thông tin giữa các module (giữa chip với chip, giữa board với board) trong một hệ thống lớn là điều bắt buộc. Một module khó có thể thực hiện tất cả các công việc của hệ thống. 

Việc truyền nhận dữ liệu này thường được thực hiện tuân theo một chuẩn giao thức nhất định. Giao thức định nghĩa cấu trúc của gói tin truyền nhận, cách kết nối giữa các module về mặt vật lý, hoặc nâng cao hơn là cách thức phát hiện và sửa lỗi trong quá trình truyền nhận.

SPI, I2C, UART là 3 giao thức cơ bản, được sử dụng trong các hệ thống nhúng. Vậy cụ thể các giao thức này là gì và chúng khác gì nhau, cùng tớ khám phá từng giao thức một nhé!
  
## 1. UART
UART (Universal asynchronous receiver-transmitteer) là giao thức phổ biến nhất, sử dụng 2 sợi dây để truyền nhận thông tin giữa 2 thiết bị:
<p align="center">
		<img src="/assets/images/image.png" alt="UART" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>

Dữ liệu sẽ được gửi tuần tự (các bit được gửi lần lượt) và bất đồng bộ (không sử dụng tín hiệu clock để kiểm soát thời gian truyền nhận data).

Nếu như không sử dụng tín hiệu clock, dữ liệu được truyền nhận như thế nào? UART giải quyết vấn đề này bằng cách định nghĩa cấu trúc của một gói tin như sau:
<p align="center">
		<img src="/assets/images/image-1.png" alt="Gói tin UART" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>
- **Start bit**: được thiết bị gửi truyền đi khi muốn bắt đầu gửi data. Trạng thái idle của data (chưa gửi thông tin) là HIGH (bit 1), do vậy **start bit** có thể được nhận diện khi data nhận được chuyển từ HIGH sang LOW.
- **Data bits**: là dữ liệu thực sự cần truyền đi (payload), thường là 8 bits nhưng có thể được config thành 7 hoặc 6 bits tùy trường hợp (việc config này phải đảm bảo giống nhau giữa 2 thiết bị).
- **Parity bit**: dùng để xác định lỗi xảy ra trong quá trình truyền nhận data. Ví dụ, nếu tuân theo parity bit chẵn, **parity bit** bằng 1 khi số bit 1 trong data bits là số chẵn, và bằng 0 khi số bit 1 trong data bits là số lẻ. Thiết bị nhận có thể đối chiếu **parity bit** và số bit 1 trong data bits trong gói tin nhận được để phát hiện lỗi.
- **Stop bits**: tùy theo từng cấu hình, có thể là 1 hoặc 2 bit để đưa tín hiệu đã truyền xong dữ liệu.

Như vậy, có thể sử dụng cấu trúc của gói tin để thiết bị nhận xác định được khi nào có gói tin UART truyền tới nó, và đọc các data trong gói tin nhận được. Tuy nhiên, trên đường truyền dữ liệu không được truyền ngay lập tức mà sẽ có độ trễ, vì vậy dữ liệu nhận được tại thiết bị nhận có thể bị lệch về thời gian so với dữ liệu truyền đi tại từ thiết bị truyền. Và độ trễ này có thể khiến cho thiết bị nhận xử lý sai dữ liệu nếu phải gửi đi với tốc độ quá nhanh, do vậy UART không thể hỗ trợ truyền nhận với tốc độ quá cao, và cũng chỉ hỗ trợ một số tốc độ truyền nhất định đã được nghiên cứu để giảm thiểu ảnh hưởng của độ trễ này (9600, 19200, 38400, 57600, và 115200).

## 2. SPI
Trái với UART, SPI (Serial Peripheral Interface) là một giao thức đồng bộ, sử dụng tín hiệu clock để đồng bộ dữ liệu truyền đi giữa các thiết bị.

Ngoài ra, trong giao thức SPI, có một thiết bị đóng vai trò master (thường là MCU) điều khiển hoặc đọc dữ liệu từ các thiết bị khác gọi là slave (thường là sensor, actuator).

Kiến trúc của SPI có thể được mô tả theo hình sau 
<p align="center">
		<img src="/assets/images/spi_arch.png" alt="Kiến trúc SPI" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>
- MOSI (Master out slave in): truyền dữ liệu từ master tới slave.
- MISO (Master in slave out): truyền dữ liệu từ slave tới master.
- SCK: truyền tín hiệu clock.
- Các chân SS (Slave select) hoặc CS (Chip selecct): dùng để xác định master đang giao tiếp với slave nào

Như vậy SPI đã có tín hiệu clock để đồng bộ dữ liệu truyền nhận, vậy có cần định nghĩa cấu trúc data truyền nhận (data frame) nữa không? Đối với SPI thì câu trả lời là không, master và slave sẽ đọc dữ liệu trên đường dây theo tín hiệu clock. Hình dưới là ví dụ dữ liệu được đọc tại cạnh lên (rising edge) của tín hiệu clock

<p align="center">
		<img src="/assets/images/spi_frame.png" alt="Tín hiệu clock SPI" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>

Đôi khi tín hiệu có thể được đọc tại cạnh xuống (falling edge), do vậy khi code cần dựa vào datasheet của thiết bị để cấu hình cho phù hợp.

## 3. I2C
Có thể thấy khi sử dụng SPI để giao tiếp với nhiều thiết bị, ta cần phải nối rất nhiều dây kết nối. Giao thức I2C (Inter-intergrated Circuit) sinh ra để giải quyết vấn đề này, cho phép kết nối nhiều thiết bị với chỉ 2 dây (SDA và SCL)
<p align="center">
		<img src="/assets/images/i2c_arch.png" alt="Kiến trúc I2C" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>
- SDA: đường dây truyền dữ liệu. Khác với SPI sử dụng 2 đường dây riêng biệt cho 2 chiều truyền nhận từ master tới slave và từ slave tới master, I2C chỉ sử dụng một đường dây SDA duy nhất, do đó tại mỗi thời điểm chỉ có thể master chỉ có thể truyền **hoặc** nhận dữ liệu từ các slave
- SCL: tín hiệu clock dùng để đồng bộ quá trình truyền nhận.

Có thể thấy I2C không có các chân Chip Select, vậy làm như thế nào để xác định master đang muốn giao tiếp với slave nào? I2C sử dụng cơ chế địa chỉ (address), mỗi slave sẽ được định danh với một địa chỉ cố định, và chỉ thực hiện giao tiếp khi data nhận được chứa địa chỉ khớp với địa chỉ của nó. Do vậy, gói tin I2C có cấu trúc như sau:
<p align="center">
		<img src="/assets/images/i2c_data.png" alt="Gói tin I2C" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>
- **Start**: là điều kiện của tín hiệu clock (được điều khiển bởi master)
<p align="center">
		<img src="/assets/images/i2c_condition.png" alt="Điều kiện start/stop trong I2C" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>
- **Address**: chứa địa chỉ của slave mà master đang muốn giao tiếp
- **Read/Write**: xác định master đang muốn gửi hay nhận dữ liệu với slave
- **Acknowledge**: thông báo từ slave rằng đã nhận được yêu cầu truyền nhận dữ liệu
- **Data pack**: dữ liệu cần truyền tới slave hoặc nhận được từ slave
- **Acknowledge**: thông báo từ slave rằng đã truyền nhận xong dữ liệu
- **Data pack**: dữ liệu tiếp theo cần truyền hoặc được nhận
- ...
- **Stop**: là điều kiện của tín hiệu clock (được điều khiển bởi master)
<p align="center">
		<img src="/assets/images/i2c_condition.png" alt="Điều kiện start/stop trong I2C" style="width:600px;max-width:100%;display:block;margin:auto;" />
</p>

Như vậy, tớ đã trình bày về từng UART, SPI và I2C. Mỗi giao thức sẽ phù hợp với từng ứng dụng khác nhau và yêu cầu khác nhau (về tốc độ truyền gửi dữ liệu, khoảng cách giao tiếp, số thiết bị cần giao tiếp, ...). Hiện nay, trong nhiều ứng dụng, việc hiện thực xử lý dữ liệu từ các giao thức này đa phần đều đã được cung cấp với các thư viện, chip support package hay các hàm HAL (hardware abstraction layer) từ những nhà sản xuất chip hoặc từ cộng đồng. Tuy nhiên, ta cũng cần phải hiểu về cách thức hoạt động cũng như các thông số cơ bản của từng giao thức để biết cách cấu hình và debug khi phát hiện bug xảy ra trong hệ thống.
